<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hex to Token</title>
  <style>
    :root{
      --bg: #FFFFFF;
      --text: #0A0A0A;
      --muted: #99A1AF;
      --subtle: #6A7282;
      --card: #F3F4F6;
      --line: #E5E7EB;
      --primary: #2B7FFF;
      --radius-card: 4px;
      --radius-chip: 6px;
      --shadow: 0px 20px 25px -5px rgba(0, 0, 0, 0.1), 0px 8px 10px -6px rgba(0, 0, 0, 0.1);
      --mono: ui-monospace, Menlo, Monaco, "SF Mono", "Roboto Mono", "Cascadia Mono", Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
    }

    *{ box-sizing: border-box; }
    html, body{
      margin:0; padding:0;
      width:400px; height:660px;
      background: transparent;
      font-family: var(--sans);
      color: var(--text);
    }

    .app{
      position: relative;
      width: 400px;
      height: 660px;
      background: var(--bg);
      border-radius: var(--radius-app);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .header{
      padding: 16px 16px 0 16px;
    }

    .title{
      font-weight: 700;
      font-size: 20px;
      line-height: 28px;
      letter-spacing: -0.449219px;
    }

    .main{
      padding: 12px 16px 0 16px;
      /* footer(81px) + top padding 고려해서 scroll 영역 잡기 */
      height: calc(660px - 28px - 16px - 12px - 81px);
      overflow: auto;
    }

    .section{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }

    .section-title{
      font-weight: 700;
      font-size: 14px;
      line-height: 20px;
      letter-spacing: -0.150391px;
    }

    .form{
      display:flex;
      flex-direction:column;
      gap: 16px;
    }

     #groupList{
   gap: 10px;
    }

    .row{
      display:flex;
      align-items:center;
      gap: 16px;
      min-height: 32px;
    }

    .label{
      width: 100px;      
      font-weight: 600;
      font-size: 12px;
      line-height: 16px;
      color: #6A7282;
    }

    select.select{
      width: 252px;
      height: 32px;
      border: 0;
      border-radius: var(--radius-card);
      background: var(--card);
      padding: 0 32px 0 10px;
      font-size: 12px;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;utf8,<svg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'><path d='M4 6L8 10L12 6' stroke='%236A7282' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/></svg>");
      background-position: right 12px center;
      background-repeat: no-repeat;
    }
    select.select:focus{
      outline: 2px solid rgba(43,127,255,.25);
    }

    .segmented{
      width: 252px;
      height: 48px;
      padding: 8px 8px 0 8px;
      background: var(--card);
      border-radius: var(--radius-card);
      display:flex;
      gap: 8px;
    }
    .seg{
      flex:1;
      height: 32px;
      border-radius: var(--radius-card);
      border: 0;
      background: transparent;
      font-size: 12px;
      line-height: 16px;
      font-weight: 600;
      color: var(--muted);
      cursor: pointer;
    }
    .seg.on{
      background: var(--bg);
      box-shadow: 0px 1px 3px rgba(0, 0, 0, 0.1), 0px 1px 2px -1px rgba(0, 0, 0, 0.1);
      color: #000;
    }

    .check{
      display:flex;
      align-items:center;
      gap: 8px;
      user-select:none;
      cursor: pointer;
    }
    .check input{
      width: 16px;
      height: 16px;
      border-radius: 4px;
      accent-color: #030213;
    }
    .check span{
      font-weight: 500;
      font-size: 12px;
      line-height: 16px;
    }

    #groupList .check{
      position: relative;
    }
    #groupList .check input{
      position: absolute;
      width: 18px;
      height: 18px;
      margin: 0;
      opacity: 0;
      cursor: pointer;
      z-index: 1;
    }
    #groupList .check .group-checkbox-box{
      width: 18px;
      height: 18px;
      min-width: 18px;
      min-height: 18px;
      border: 2px solid var(--line);
      border-radius: 4px;
      background: var(--bg);
      position: relative;
      flex-shrink: 0;
    }
    #groupList .check input:checked ~ .group-checkbox-box{
      border-color: var(--text);
      background: var(--text);
      color: #fff;
    }
    #groupList .check .group-checkbox-box svg{
      display: none;
      position: absolute;
      left: 2;
      top: 2;
      width: 65%;
      height: 65%;
    }
    #groupList .check input:checked ~ .group-checkbox-box svg{
      display: block;
    }

    .divider{
      margin: 20px 0;
      height: 1px;
      background: var(--line);
    }

    .colors{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .block{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .block-title{
      font-weight: 600;
      font-size: 12px;
      line-height: 16px;
    }

    .card{
      background: var(--card);
      border-radius: var(--radius-card);
      overflow: hidden;
      border: 1px solid transparent;
    }

    .list{
      display:flex;
      flex-direction:column;
    }

    .item{
      display:flex;
      align-items:center;
      gap: 12px;
      padding: 0 16px;
      height: 48px;
      border-bottom: 1px solid var(--line);
      cursor: default;
    }
    .item:last-child{ border-bottom: 0; }

    .chip{
      width: 22px;
      height: 22px;
      border: 2px solid var(--line);
      border-radius: var(--radius-chip);
      background: #000;
      flex: none;
    }
    .chip.chipAlpha{
      background-size: auto, 8px 8px;
      background-repeat: repeat, repeat;
    }

    .mono{
      font-family: var(--mono);
      font-weight: 700;
      font-size: 12px;
      line-height: 16px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .rowText{
      display:flex;
      align-items:center;
      gap: 8px;
      min-width: 0;
      flex: 1;
    }
    .hex{
      width: 110px;
      flex:none;
      text-transform: uppercase;
    }
    .hex.hexApplied{
      width: auto;
      min-width: 0;
      flex: 1;
      overflow: visible;
      text-overflow: clip;
      white-space: normal;
    }
    .count{
      font-family: var(--mono);
      font-weight: 700;
      font-size: 12px;
      color: var(--subtle);
      flex:none;
    }
    .token{
      min-width: 0;
      color: var(--text);
      opacity: .95;
    }
    .mutedHint{
      font-size: 12px;
      color: var(--subtle);
      margin-top: 4px;
    }

    .clickable{
      cursor: pointer;
    }
    .clickable:hover{
      background: rgba(255,255,255,.6);
    }
    .selected{
      outline: 2px solid rgba(43,127,255,.35);
      outline-offset: -2px;
    }

    .noMatchRowWrap{ display: flex; flex-direction: column; }
    .inlineCandidates{ background-color: #E7EBF2; }

    /* Suggestions panel */
    .suggestPanel{
      margin-top: 10px;
      padding: 10px;
      background: var(--card);
      border-radius: var(--radius-card);
      border: 1px solid transparent;
    }
    .suggestHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      margin-bottom: 10px;
    }
    .suggestTitle{
      font-weight: 600;
      font-size: 12px;
      line-height: 16px;
    }
    .suggestTarget{
      font-family: var(--mono);
      font-weight: 700;
      font-size: 12px;
      color: var(--subtle);
      text-transform: uppercase;
      white-space: nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .swatch{
      background: var(--bg);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 8px;
      cursor: pointer;
      min-height: 58px;
      display:flex;
      flex-direction:column;
      gap: 6px;
    }
    .swatch:hover{
      border-color: rgba(43,127,255,.4);
    }
    .swatch.sel{
      outline: 2px solid rgba(43,127,255,.45);
      outline-offset: 0;
    }
    .swatchTop{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .swatchChip{
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid var(--line);
      background: #000;
      flex:none;
    }
    .swatchHex{
      font-family: var(--mono);
      font-weight: 700;
      font-size: 11px;
      color: var(--text);
      text-transform: uppercase;
      white-space: nowrap;
    }
    .swatchName{
      font-size: 11px;
      font-weight: 600;
      color: var(--subtle);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .footer{
      position: absolute;
      left: 0;
      bottom: 0;
      width: 400px;
      height: 81px;
      padding: 17px 16px 0 16px;
      background: var(--bg);
      border-top: 1px solid var(--line);
      display:flex;
      gap: 12px;
    }

    .btn{
      flex: 1;
      height: 48px;
      border-radius: var(--radius-card);
      font-weight: 600;
      font-size: 14px;
      line-height: 20px;
      letter-spacing: -0.150391px;
      cursor: pointer;
    }
    .btn-outline{
      background: var(--bg);
      border: 2px solid var(--primary);
      color: var(--primary);
    }
    .btn-primary{
      background: var(--primary);
      border: 0;
      color: #fff;
    }
    .btn:disabled{
      opacity: .5;
      cursor: not-allowed;
    }

  </style>
</head>

<body>
  <div class="app">
    <header class="header">
      <div class="title">Hex to Token</div>
    </header>

    <main class="main">
      <section class="section">
        <div class="section-title">Settings</div>

        <div class="form">
          <div class="row">
            <div class="label">Collection</div>
            <select id="collection" class="select">
              <option value="">Loading...</option>
            </select>
          </div>

          <div id="groupRowWrap" class="row" style="display:none; align-items:flex-start;">
            <div class="label" style="padding-top:0px;">Group</div>
            <div id="groupList" class="form"></div>
          </div>

          <div id="modeRowWrap" class="row" style="align-items:center; display:none;">
            <div class="label">Mode</div>
            <div class="segmented" role="tablist" aria-label="Mode">
              <button id="modeLight" class="seg on" type="button">Light</button>
              <button id="modeDark" class="seg" type="button">Dark</button>
            </div>
          </div>
        </div>

      </section>

      <div class="divider"></div>

      <section class="section colors">
        <div class="section-title">Colors</div>

        <div class="block">
          <div class="block-title">Matched colors</div>
          <div class="card">
            <div id="matchedList" class="list">
              <div class="item">
                <div class="mono" style="color:var(--subtle);">Run Scan to see results</div>
              </div>
            </div>
          </div>
        </div>

        <div class="block">
          <div class="block-title">No match colors (click to see token candidates)</div>
          <div class="card">
            <div id="noMatchList" class="list">
              <div class="item">
                <div class="mono" style="color:var(--subtle);">Run Scan to see results</div>
              </div>
            </div>
          </div>

          <div id="suggestPanel" class="suggestPanel" style="display:none;">
            <div class="suggestHeader">
              <div class="suggestTitle">Token candidates</div>
              <div class="suggestTarget" id="suggestTarget">—</div>
            </div>
            <div id="suggestGrid" class="grid"></div>
            <div class="mutedHint" id="suggestHint" style="display:none;">
              Tip: choose a token and apply it with “Apply”.
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <button id="scanBtn" class="btn btn-outline" type="button">Scan</button>
      <button id="applyBtn" class="btn btn-primary" type="button">Apply</button>
    </footer>
  </div>

  <script>
    // ---------- state ----------
    const state = {
      mode: "Light",
      collection: "",
      hasGroups: false,
      groups: [],
      selectedGroups: [],
      availableModes: [],   // ["Light"], ["Dark"], or ["Light","Dark"] from collection.modes
      matchedColors: [],   // [{hex,count,variableId,variableName}]
      noMatchColors: [],   // [{hex,alpha?,count}]
      expandedNoMatchKey: null,
      suggestionsCache: {},
      loadingSuggestionsKey: null,
      appliedNoMatchMap: {},   // { [hex]: { name, hex } } after candidate apply success
      pendingApply: null       // { hex, name, tokenHex } while waiting for applyTokenToColorResult
    };

    const CHECKERBOARD_DATA_URI = "url(\"data:image/svg+xml;utf8,<svg width='8' height='8' xmlns='http://www.w3.org/2000/svg'><rect width='4' height='4' fill='%23E5E7EB'/><rect x='4' y='4' width='4' height='4' fill='%23E5E7EB'/><rect x='4' y='0' width='4' height='4' fill='%23FFFFFF'/><rect x='0' y='4' width='4' height='4' fill='%23FFFFFF'/></svg>\")";

    function formatHexDisplay(hex, alpha){
      const h = (hex || "").replace(/^#/, "").toUpperCase();
      if (alpha == null || alpha >= 0.995) return "#" + h;
      return "#" + h + " / A" + Math.round(alpha * 100);
    }

    function hexToRgb255(hex){
      const s = (hex || "").replace(/^#/, "").trim();
      if (s.length !== 6) return { r: 0, g: 0, b: 0 };
      const n = parseInt(s, 16);
      if (isNaN(n)) return { r: 0, g: 0, b: 0 };
      return { r: (n >> 16) & 0xff, g: (n >> 8) & 0xff, b: n & 0xff };
    }

    function setChipStyle(chip, hex, alpha){
      if (alpha != null && alpha < 0.995) {
        const rgb = hexToRgb255(hex);
        chip.classList.add("chipAlpha");
        chip.style.background = "linear-gradient(rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + alpha + "), rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + alpha + ")), " + CHECKERBOARD_DATA_URI;
      } else {
        chip.classList.remove("chipAlpha");
        chip.style.background = "#" + (hex || "000").replace(/^#/, "");
      }
    }

    function noMatchKey(it){ return it.hex + "|" + (it.alpha ?? 1); }

    function createCheckSvg(){
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("viewBox", "0 0 12 10");
      svg.setAttribute("fill", "none");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M 2 6 L 5 9 L 10 2");
      path.setAttribute("stroke", "currentColor");
      path.setAttribute("stroke-width", "3");
      path.setAttribute("stroke-linecap", "round");
      path.setAttribute("stroke-linejoin", "round");
      svg.appendChild(path);
      return svg;
    }

    // ---------- helpers ----------
    const $ = (id) => document.getElementById(id);

    function setMode(mode){
      state.mode = mode;
      $("modeLight").classList.toggle("on", mode === "Light");
      $("modeDark").classList.toggle("on", mode === "Dark");
    }

    function updateModeRow(){
      const modes = state.availableModes || [];
      const wrap = $("modeRowWrap");
      if (modes.length === 0) {
        wrap.style.display = "none";
        return;
      }
      wrap.style.display = "";
      $("modeLight").style.display = modes.indexOf("Light") !== -1 ? "" : "none";
      $("modeDark").style.display = modes.indexOf("Dark") !== -1 ? "" : "none";
      if (modes.indexOf(state.mode) === -1) {
        state.mode = modes[0];
        setMode(state.mode);
      }
    }

    function emptyRow(text){
      const row = document.createElement("div");
      row.className = "item";
      const t = document.createElement("div");
      t.className = "mono";
      t.style.color = "var(--subtle)";
      t.textContent = text;
      row.appendChild(t);
      return row;
    }

    function renderMatched(){
      const list = $("matchedList");
      list.innerHTML = "";
      if (!state.matchedColors.length){
        list.appendChild(emptyRow("No matched colors"));
        return;
      }

      for (const it of state.matchedColors){
        const row = document.createElement("div");
        row.className = "item";

        const chip = document.createElement("div");
        chip.className = "chip";
        setChipStyle(chip, it.hex, it.alpha);

        const rowText = document.createElement("div");
        rowText.className = "rowText";

        const hex = document.createElement("div");
        hex.className = "mono hex";
        hex.textContent = formatHexDisplay(it.hex, it.alpha);

        const token = document.createElement("div");
        token.className = "mono token";
        token.textContent = (it.variableName ?? "—");

        rowText.appendChild(hex);
        rowText.appendChild(token);

        const count = document.createElement("div");
        count.className = "count";
        count.textContent = it.count > 1 ? `x${it.count}` : "";

        row.appendChild(chip);
        row.appendChild(rowText);
        row.appendChild(count);

        list.appendChild(row);
      }
    }

    function renderNoMatch(){
      const list = $("noMatchList");
      list.innerHTML = "";
      if (!state.noMatchColors.length){
        list.appendChild(emptyRow("No no-match colors"));
        return;
      }

      for (const it of state.noMatchColors){
        const key = noMatchKey(it);
        const wrap = document.createElement("div");
        wrap.className = "noMatchRowWrap";

        const row = document.createElement("div");
        row.className = "item clickable";
        if (state.expandedNoMatchKey === key) row.classList.add("selected");

        const chip = document.createElement("div");
        chip.className = "chip";
        setChipStyle(chip, it.hex, it.alpha);

        const rowText = document.createElement("div");
        rowText.className = "rowText";

        const hex = document.createElement("div");
        const applied = state.appliedNoMatchMap[key];
        hex.className = applied ? "mono hex hexApplied" : "mono hex";
        hex.textContent = applied
          ? formatHexDisplay(it.hex, it.alpha) + " → " + (applied.name || "—") + " (" + (applied.hex || "").toUpperCase() + ")"
          : formatHexDisplay(it.hex, it.alpha);

        rowText.appendChild(hex);

        const count = document.createElement("div");
        count.className = "count";
        count.textContent = it.count > 1 ? `x${it.count}` : "";

        row.appendChild(chip);
        row.appendChild(rowText);
        row.appendChild(count);

        row.onclick = () => {
          if (state.expandedNoMatchKey === key) {
            state.expandedNoMatchKey = null;
          } else {
            state.expandedNoMatchKey = key;
            if (!state.suggestionsCache[key]) {
              state.loadingSuggestionsKey = key;
              syncSelectedGroupsFromCheckboxes();
              parent.postMessage({
                pluginMessage: {
                  type: "getSuggestions",
                  hex: it.hex,
                  mode: state.mode,
                  collection: state.collection,
                  groupPrefixes: getSelectedGroupPrefixes()
                }
              }, "*");
            }
          }
          renderNoMatch();
        };

        const inlineCandidates = document.createElement("div");
        inlineCandidates.className = "inlineCandidates";
        inlineCandidates.style.display = state.expandedNoMatchKey === key ? "block" : "none";

        if (state.expandedNoMatchKey === key) {
          if (state.loadingSuggestionsKey === key && !state.suggestionsCache[key]) {
            inlineCandidates.appendChild(emptyRow("Loading..."));
          } else if (state.suggestionsCache[key]) {
            const items = state.suggestionsCache[key];
            if (!items.length) {
              inlineCandidates.appendChild(emptyRow("No candidates found"));
            } else {
              for (const s of items) {
                const itemRow = document.createElement("div");
                itemRow.className = "item clickable";

                const itemChip = document.createElement("div");
                itemChip.className = "chip";
                setChipStyle(itemChip, s.hex, s.alpha);

                const itemRowText = document.createElement("div");
                itemRowText.className = "rowText";

                const itemName = document.createElement("div");
                itemName.className = "mono token";
                itemName.textContent = s.name ?? "—";

                const itemHex = document.createElement("div");
                itemHex.className = "mono hex";
                itemHex.textContent = formatHexDisplay(s.hex, s.alpha);

                itemRowText.appendChild(itemName);
                itemRowText.appendChild(itemHex);

                itemRow.appendChild(itemChip);
                itemRow.appendChild(itemRowText);

                itemRow.onclick = (e) => {
                  e.stopPropagation();
                  state.pendingApply = { key: key, hex: it.hex, alpha: it.alpha, name: s.name || "", tokenHex: s.hex || "" };
                  parent.postMessage({
                    pluginMessage: { type: "applyTokenToColor", hex: it.hex, variableId: s.variableId, alpha: it.alpha }
                  }, "*");
                };
                inlineCandidates.appendChild(itemRow);
              }
            }
          } else {
            inlineCandidates.appendChild(emptyRow("Loading..."));
          }
        }

        wrap.appendChild(row);
        wrap.appendChild(inlineCandidates);
        list.appendChild(wrap);
      }
    }

    function renderAll(){
      renderMatched();
      renderNoMatch();
    }

    function getSelectedGroupPrefixes(){
      if (!state.hasGroups || !state.selectedGroups.length) return null;
      return state.selectedGroups.map(function(g){ return g + "/"; });
    }

    function syncSelectedGroupsFromCheckboxes(){
      const list = $("groupList");
      state.selectedGroups = [];
      list.querySelectorAll("input[type=checkbox]:checked").forEach(function(cb){
        const g = cb.getAttribute("data-group");
        if (g && g !== "__all__") state.selectedGroups.push(g);
      });
      const allCb = list.querySelector("input[data-group=\"__all__\"]");
      if (allCb) allCb.checked = state.groups.length > 0 && state.selectedGroups.length === state.groups.length;
    }

    function updateGroupCheckboxes(){
      const list = $("groupList");
      list.innerHTML = "";

      const allLabel = document.createElement("label");
      allLabel.className = "check";
      const allInput = document.createElement("input");
      allInput.type = "checkbox";
      allInput.setAttribute("data-group", "__all__");
      allInput.checked = state.groups.length > 0 && state.selectedGroups.length === state.groups.length;
      allInput.addEventListener("change", function(){
        if (allInput.checked) {
          state.selectedGroups = state.groups.slice();
          list.querySelectorAll("input[type=checkbox][data-group]").forEach(function(cb){
            if (cb.getAttribute("data-group") !== "__all__") cb.checked = true;
          });
        } else {
          state.selectedGroups = [];
          list.querySelectorAll("input[type=checkbox][data-group]").forEach(function(cb){
            if (cb.getAttribute("data-group") !== "__all__") cb.checked = false;
          });
        }
      });
      const allBox = document.createElement("span");
      allBox.className = "group-checkbox-box";
      allBox.appendChild(createCheckSvg());
      const allSpan = document.createElement("span");
      allSpan.textContent = "All";
      allLabel.appendChild(allInput);
      allLabel.appendChild(allBox);
      allLabel.appendChild(allSpan);
      list.appendChild(allLabel);

      for (const g of state.groups) {
        const label = document.createElement("label");
        label.className = "check";
        const input = document.createElement("input");
        input.type = "checkbox";
        input.setAttribute("data-group", g);
        if (state.selectedGroups.indexOf(g) !== -1) input.checked = true;
        input.addEventListener("change", function(){ syncSelectedGroupsFromCheckboxes(); });
        const box = document.createElement("span");
        box.className = "group-checkbox-box";
        box.appendChild(createCheckSvg());
        const span = document.createElement("span");
        span.textContent = g;
        label.appendChild(input);
        label.appendChild(box);
        label.appendChild(span);
        list.appendChild(label);
      }
    }

    function showGroupRow(show){
      $("groupRowWrap").style.display = show ? "" : "none";
      state.hasGroups = show;
      if (!show) state.groups = [];
    }

    // ---------- UI events ----------
    $("collection").addEventListener("change", (e) => {
      state.collection = e.target.value;
      parent.postMessage({ pluginMessage: { type: "getGroups", collection: state.collection } }, "*");
    });

    $("modeLight").addEventListener("click", () => setMode("Light"));
    $("modeDark").addEventListener("click", () => setMode("Dark"));

    $("scanBtn").addEventListener("click", () => {
      syncSelectedGroupsFromCheckboxes();
      parent.postMessage({
        pluginMessage: {
          type: "scan",
          mode: state.mode,
          collection: state.collection,
          groupPrefixes: getSelectedGroupPrefixes()
        }
      }, "*");
    });

    $("applyBtn").addEventListener("click", () => {
      parent.postMessage({
        pluginMessage: { type: "apply" }
      }, "*");
    });

    // ---------- inbound from plugin ----------
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      if (msg.type === "scanUI") {
        state.matchedColors = msg.matchedColors || [];
        state.noMatchColors = msg.noMatchColors || [];
        state.appliedNoMatchMap = {};
        if (state.expandedNoMatchKey && !state.noMatchColors.some(function(x){ return noMatchKey(x) === state.expandedNoMatchKey; })) {
          state.expandedNoMatchKey = null;
        }
        renderAll();
        return;
      }

      if (msg.type === "applyTokenToColorResult") {
        if (msg.appliedCount > 0 && state.pendingApply && state.pendingApply.key) {
          state.appliedNoMatchMap[state.pendingApply.key] = {
            name: state.pendingApply.name,
            hex: state.pendingApply.tokenHex
          };
          state.pendingApply = null;
          renderNoMatch();
        } else {
          state.pendingApply = null;
        }
        return;
      }

      if (msg.type === "suggestions") {
        if (state.loadingSuggestionsKey != null) {
          state.suggestionsCache[state.loadingSuggestionsKey] = msg.items || [];
        }
        state.loadingSuggestionsKey = null;
        renderNoMatch();
        return;
      }

      if (msg.type === "collections") {
        const sel = $("collection");
        sel.innerHTML = "";
        const names = msg.collectionNames || [];
        for (const name of names) {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          sel.appendChild(opt);
        }
        state.collection = names.length ? names[0] : "";
        if (state.collection) {
          parent.postMessage({ pluginMessage: { type: "getGroups", collection: state.collection } }, "*");
        } else {
          showGroupRow(false);
          state.availableModes = [];
          updateModeRow();
        }
        return;
      }

      if (msg.type === "groups") {
        const groups = msg.groups || [];
        state.availableModes = msg.modes || [];
        if (groups.length > 0) {
          state.groups = groups;
          state.selectedGroups = [];
          updateGroupCheckboxes();
          showGroupRow(true);
        } else {
          showGroupRow(false);
        }
        updateModeRow();
        return;
      }

      if (msg.type === "toast") {
        return;
      }
    };

    setMode("Light");
    parent.postMessage({ pluginMessage: { type: "getCollections" } }, "*");
  </script>
</body>
</html>
